{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Project introduction","text":""},{"location":"arcagi/","title":"Introduction to ARC-AGI tasks","text":"<p>In this project we use mainly ARC-AGI 1 dataset. It consists of examples such as</p> <p></p> <p>and user is given a completion task like this</p> <p></p> <p>User needs to modify the grid size and then color cells using 10 colors (including black).</p> <p></p> <p>For humans it is quite intuitive that we need to extend the small star into a bigger star using the colors of the small star. So we can provide the solution</p> <p></p> <p>But how can a computer program understand the rules just from the examples?</p> <p>One way to solve it is to find programs that generate output from the given input. For example,</p> <p>Find a square that has different (than its own color) color squares on its each four sides</p> <ul> <li>fill all diagonal squares until distance 2 with its color</li> <li>for each four adjacent squares, fill the square behind them with the color of the adjacent square in question</li> </ul> <p>This is not the only program to create the correct output and we cannot know what are the actual rules: Should we check that all four adjacent squares are the same color? Probably but we don't have an example for that.</p> <p>In this project, we study if concept blending can help us to solve these problems. In this case, such concepts could be rotational symmetry, center, or line (ray). For this, we use MeTTa hypergraph language from Hyperon framework.</p> <p>Next: MeTTa language</p>"},{"location":"concept-blending/","title":"Concept Blending","text":"<p>This page documents the blending mechanism in MeTTa.</p>"},{"location":"concept-blending/#mechanism-logic","title":"Mechanism Logic","text":"<p>The core logic relies on the <code>Match</code> operation.</p> <p>```scheme (Match (Adjacent ?x ?y) ...)</p>"},{"location":"log/","title":"Log","text":"<p>Feb 7: First documentation created!</p>"},{"location":"metta/","title":"Introduction to MeTTa","text":"<p>This project uses MeTTa (Meta Type Talk), the native language of the OpenCog Hyperon framework.</p>"},{"location":"metta/#why-metta","title":"Why MeTTa?","text":"<p>Unlike standard programming languages (like Python) that separate data from code, MeTTa treats everything as an Atom. This allows us to represent visual grids, logical rules, and concept blending operations in a single, unified Atomspace.</p> <p>For \"Pattern Discovery,\" MeTTa provides three critical features out of the box: 1.  Pattern Matching: You can search for complex structural patterns without writing custom loops. 2.  Unification: The system can automatically fill in variables (like <code>?x</code> or <code>?color</code>) to find solutions. 3.  Homoiconicity: Code can rewrite itself. This is useful for concept blending, where the system invents new rules on the fly.</p>"},{"location":"metta/#data-representation","title":"Data Representation","text":"<p>In this project, we do not store grids as 2D arrays (like <code>grid[0][1]</code>). Instead, we explode them into a Hypergraph of symbolic facts. For example, a simple red pixel at coordinates (1, 2) is represented as a set of linked atoms:</p> <pre><code>; Primitive entities (Symbols)\n(IsA c1 Cell)\n(HasColor c1 Red)\n(HasCoord c1 (1 2))\n\n; Relations between entities\n(Adjacent c1 c2)\n(Direction c1 c2 Right)\n</code></pre> <p>More information about MeTTa language can be found at MeTTa language homepage.</p> <p>Next: Resources</p>"},{"location":"resources/","title":"Resources for solving ARC-AGI type tasks","text":""},{"location":"resources/#arc-agi","title":"ARC-AGI","text":"<p>https://arcprize.org/arc-agi/1/</p>"}]}